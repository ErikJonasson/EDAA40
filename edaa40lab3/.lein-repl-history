(use 'edaa40.lab3 :reload)
(print-boards (first-moves B0-OGT))
(use 'edaa40.lab3 :reload)
(print-boards (first-moves B0-OGT))
(print-boards (rand-moves B0-OGT))
(use 'edaa40.lab3 :reload)
(gametree-depth B0-GT
)
(gametree-depth B1-GT)
(gametree-depth B2-GT)
(gametree-depth B0-RGT)
(gametree-depth B1-RGT)
(gametree-depth B2-RGT)
(gametree-count B0-OGT)
(gametree-count B1-OGT)
(gametree-count B2-OGT)
(print-boards (rand-moves B0-OGT))
(use 'edaa40.lab3 :reload)
(print-boards (rand-moves B0-OGT))
(print-boards (rand-moves B2-OGT))
(print-boards (rand-moves B1-OGT))
(use 'edaa40.lab3 :reload)
(print-boards (rand-moves B1-OGT))
(use 'edaa40.lab3 :reload)
(threeinarow X [_ _ _ _ _ _ X X X]  (winning-lines 1))
(use 'edaa40.lab3 :reload)
(threeinarow X [_ _ _ _ _ _ X X X]  (winning-lines 1))
winning-lines
(winning-lines)
(threeinarow X [_ _ _ _ _ _ X X X]  (winning-lines 1)))
(threeinarow X [_ _ _ _ _ _ X X X]  (winning-lines 1))
(defn- threeinarow 
   "determines whether the specified line (a vector of three indices) is 
   fully occupied by player p in the board b"
  [p b ln]
 
(for [v ln] (if(= (b v) p) true false))
)
(threeinarow X [_ _ _ _ _ _ X X X]  (winning-lines 1))
(use 'edaa40.lab3 :reload)
(count (moves X B0)) 9)
(count (moves X B0))
(moves X B0)
(use 'edaa40.lab3 :reload)
(moves X B0)
(use 'edaa40.lab3 :reload)
(count (moves X B0))
(use 'edaa40.lab3 :reload)
(count (moves X B0))
(print-boards (moves X B0))
(print-boards (moves X B1))
(use 'edaa40.lab3 :reload)
(filter _ [0 0 0 0])
(filter _ [0 0 0 _])
(use 'edaa40.lab3 :reload)
(use 'edaa40.lab3 :reload)¨
(use 'edaa40.lab3 :reload)
(gametree X [O _ _ _ _ _ _ _ _])
(gametree X [O _ _ X O X O X O])
(use 'edaa40.lab3 :reload)
(gametree-count B0-GT)
(use 'edaa40.lab3 :reload)
