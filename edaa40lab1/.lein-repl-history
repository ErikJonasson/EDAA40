(use 'edaa40.lab1 :reload)
(powerset #{1 2 3 4})
(use 'edaa40.lab1 :reload)
r1
r2
r3
r4
(use 'edaa40.lab1 :reload)
r1props
(use 'edaa40.lab1 :reload)
r1props
r2props
r3props
r4props
(use 'edaa40.lab1 :reload)
r5
r6
(use 'edaa40.lab1 :reload)
r6
exit
(use 'edaa40'lab1 :reload)
(use 'edaa40.lab1 :reload)
(println true "true :)
")
(use 'edaa40.lab1 :reload)
(powerset #{1 2 3 4})
(use 'edaa40.lab1 :reload)
(cartesian [1 2])
(cartesian [1 2] [1])
(use 'edaa40.lab1 :reload)
(cartesian [1 2] [1])
(use 'edaa40.lab1 :reload)
(cartesian [1 2] [1])
(cartesian [] [1])
(cartesian [1 2] [1])
(cartesian [] [1])
(cartesian [1] [])
(cartesian [1] [1])
(cartesian [1 2 2 ] [1])
(cartesian [1 2 2 ] [1 2 2 3 ])
(cartesian [ ] [1 2 2 3 ])
(cartesian [ ] [])
(cartesian [1 ] [])
(cartesian #{1 2 3 4 5} #{2 3 4 7 8})
(cartesian [ ] [])
(cartesian [1 ] [])
(cartesian [ ] [])
(cartesian [4 ] [])
(cartesian [4 ] [7])
(cartesian [4] [7])
(cartesian [0] [7])
(cartesian [1] [7])
(cartesian [0] [7])
(use 'edaa40.lab1 :reload)
(dom [1])
(dom [1<2])
(dom[1<2])
(dom(1.2)
sd
s
w
q
(use 'edaa40.lab1 :reload)
(cartesian [1] [7])
(cartesian #{1 2 3 4 5} #{2 3 4 7 8})
(cartesian [1] [7])
(use 'edaa40.lab1 :reload)
(cartesian [1] [7])
test
cartesian test 1
(#(set
   (for[x %1, y %2]
(use 'edaa40.lab1 :reload)
(cartesian #{1 2 3 4 5} #{2 3 4 7 8})
(use 'edaa40.lab1 :reload)
(cartesian #{1 2 3 4 5} #{2 3 4 7 8})
(use 'edaa40.lab1 :reload)
(cartesian #{1 2 3 4 5} #{2 3 4 7 8})
(use 'edaa40.lab1 :reload)
(cartesian #{1 2 3 4 5} #{2 3 4 7 8})
(use 'edaa40.lab1 :reload)
(cartesian #{1 2 3 4 5} #{2 3 4 7 8})
(use 'edaa40.lab1 :reload)
(cartesian #{1 2 3 4 5} #{2 3 4 7 8})
(rng #{1 2 3 4 5})
(use 'edaa40.lab1 :reload)
(rng #{1 2 3 4 5})
(com #{1 2 3 4 5})
(dom #{1 2 3 4 5})
(use 'edaa40.lab1 :reload)¨
(defn image-of 
  ; "computes the image of the element x under R"
   [R x] 
 
(set (for [r R] (when (= (first r) x) (second r))
)
 )
(image-of #{[1 :a] [2 :b] [1 :c] [3 :a]} 1)
(use 'edaa40.lab1 :reload)¨
(image-of #{[1 :a] [2 :b] [1 :c] [3 :a]} 1)
(use 'edaa40.lab1 :reload)¨
(image-of #{[1 :a] [2 :b] [1 :c] [3 :a]} 1)
(use 'edaa40.lab1 :reload)¨
(inverse #{[1 :a] [2 :b] [1 :c] [3 :a]})
(use 'edaa40.lab1 :reload)¨
(inverse #{[1 :a] [2 :b] [1 :c] [3 :a]})
(use 'edaa40.lab1 :reload)¨
(inverse #{[1 :a] [2 :b] [1 :c] [3 :a]})
(use 'edaa40.lab1 :reload)¨
(inverse #{[1 :a] [2 :b] [1 :c] [3 :a]})
(use 'edaa40.lab1 :reload)¨
(inverse #{[1 :a] [2 :b] [1 :c] [3 :a]})
(use 'edaa40.lab1 :reload)¨
(inverse #{[1 :a] [2 :b] [1 :c] [3 :a]})
(use 'edaa40.lab1 :reload)¨
(inverse #{[1 :a] [2 :b] [1 :c] [3 :a]})
(use 'edaa40.lab1 :reload)¨
(inverse #{[1 :a] [2 :b] [1 :c] [3 :a]})
(use 'edaa40.lab1 :reload)¨
 (defn reflexive?
   "tests whether R is reflexive over A"
 
   [R A]
   (set(for [r R] (= first second))
))
(reflexive? #{[1 1] [1 2] [1 3] [2 2] [2 3] [3 3]} #{1 2 3})
(use 'edaa40.lab1 :reload)¨
(reflexive? #{[1 1] [1 2] [1 3] [2 2] [2 3] [3 3]} #{1 2 3})
(use 'edaa40.lab1 :reload)¨
(reflexive? #{[1 1] [1 2] [1 3] [2 2] [2 3] [3 3]} #{1 2 3})
(use 'edaa40.lab1 :reload)¨
(reflexive? #{[1 1] [1 2] [1 3] [2 2] [2 3] [3 3]} #{1 2 3})
(use 'edaa40.lab1 :reload)¨
(reflexive? #{[1 1] [1 2] [1 3] [2 2] [2 3] [3 3]} #{1 2 3})
(use 'edaa40.lab1 :reload)¨
inv1 [1 2]
inv1 [[1 2]]
inv1[[1 2]]
[[1 2]] inv1
(inv1 [[1 2]])
(inv1 [1 2])
(use 'edaa40.lab1 :reload)
(inv1 [[1 2]])
(inv1 [1 2])
(use 'edaa40.lab1 :reload)
(symmetric? #{[1 1] [1 2] [1 3] [2 2] [2 3] [3 3]})
(use 'edaa40.lab1 :reload)
(symmetric? #{[1 1] [1 2] [1 3] [2 2] [2 3] [3 3]})
(use 'edaa40.lab1 :reload)
(symmetric? #{[1 1] [1 2] [1 3] [2 2] [2 3] [3 3]})
(use 'edaa40.lab1 :reload)
(symmetric? #{[1 1] [1 2] [1 3] [2 2] [2 3] [3 3]})
(use 'edaa40.lab1 :reload)
(symmetric? #{[1 1] [1 2] [1 3] [2 2] [2 3] [3 3]})
(use 'edaa40.lab1 :reload)
(symmetric? #{[1 1] [1 2] [1 3] [2 2] [2 3] [3 3]})
(defn symmetric?
   "tests whether R is symmetric"
 
   [R]
 (every? #(contains? (for [r R] (inv1 r))) R)
 )
(defn symmetric?
   "tests whether R is symmetric"
 
   [R]
 (every? #(contains? (for [r R] (inv1 r))) R)
)
(defn symmetric?
   "tests whether R is symmetric"
 
   [R]
 (every? #(contains? (for [r R] (inv1 r))) R)
 (every? #(contains? (for [r R] (inv1 r))) R
(defn symmetric?
   "tests whether R is symmetric"
 
   [R]
 (every? #(contains? (for [r R] (inv1 r))) R)
 )
(use 'edaa40.lab1 :reload)
(symmetric? #{[1 1] [1 2] [1 3] [2 2] [2 3] [3 3]})
(use 'edaa40.lab1 :reload)
(symmetric? #{[1 1] [1 2] [1 3] [2 2] [2 3] [3 3]})
(use 'edaa40.lab1 :reload)
(symmetric? #{[1 1] [1 2] [1 3] [2 2] [2 3] [3 3]})
(use 'edaa40.lab1 :reload)
(symmetric? #{[1 1] [1 2] [1 3] [2 2] [2 3] [3 3]})
(use 'edaa40.lab1 :reload)
(symmetric? #{[1 1] [1 2] [1 3] [2 2] [2 3] [3 3]})
(use 'edaa40.lab1 :reload)
(symmetric? #{[1 1] [1 2] [1 3] [2 2] [2 3] [3 3]})
(use 'edaa40.lab1 :reload)
(symmetric? #{[1 1] [1 2] [1 3] [2 2] [2 3] [3 3]})
(use 'edaa40.lab1 :reload)
(symmetric? #{[1 1] [1 2] [1 3] [2 2] [2 3] [3 3]})
(use 'edaa40.lab1 :reload)
(symmetric? #{[1 1] [1 2] [1 3] [2 2] [2 3] [3 3]})
(use 'edaa40.lab1 :reload)
(symmetric? #{[1 1] [1 2] [1 3] [2 2] [2 3] [3 3]})
(use 'edaa40.lab1 :reload)
(symmetric? #{[1 1] [1 2] [1 3] [2 2] [2 3] [3 3]})
(use 'edaa40.lab1 :reload)
(symmetric? #{[1 1] [1 2] [1 3] [2 2] [2 3] [3 3]})
(use 'edaa40.lab1 :reload)
(symmetric? #{[1 1] [1 2] [1 3] [2 2] [2 3] [3 3]})
(use 'edaa40.lab1 :reload)
(symmetric? #{[1 1] [1 2] [1 3] [2 2] [2 3] [3 3]})
{[1 1][2 3]}
(contains? {[1 1][2 3]} [2 3])
(contains? {[1 1] [2 3]} [2 3])
(contains? {[1 1] [2 3]} 1)
(contains? {[1 1] [2 3]} 2)
(contains? {[1 1] [2 3]} 0)
(use 'edaa40.lab1 :reload)
(symmetric? #{[1 1] [1 2] [1 3] [2 2] [2 3] [3 3]})
(use 'edaa40.lab1 :reload)
(symmetric? #{[1 1] [1 2] [1 3] [2 2] [2 3] [3 3]})
(use 'edaa40.lab1 :reload)
(symmetric? #{[1 1] [1 2] [1 3] [2 2] [2 3] [3 3]})
(use 'edaa40.lab1 :reload)
(symmetric? #{[1 1] [1 2] [1 3] [2 2] [2 3] [3 3]})
(use 'edaa40.lab1 :reload)
(symmetric? #{[1 1] [1 2] [1 3] [2 2] [2 3] [3 3]})
(symmetric? #{[1 1] [1 3] [2 2] [3 1]})
(use 'edaa40.lab1 :reload)
(symmetric? #{[1 1] [1 3] [2 2] [3 1]})
(use 'edaa40.lab1 :reload)
(symmetric? #{[1 1] [1 3] [2 2] [3 1]})
(use 'edaa40.lab1 :reload)
(transitive? #{[1 1] [1 2] [1 3] [2 2] [2 3] [3 3]})
(use 'edaa40.lab1 :reload)
